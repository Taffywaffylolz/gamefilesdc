const { Client, GatewayIntentBits, EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
const fs = require('fs');
const path = require('path');
const axios = require('axios');
const archiver = require('archiver');

// Configuration
const config = {
    allowedGuildIds: ['1375167410851680266', 'YOUR_GUILD_ID_2'],
    blacklistedUserIds: [],
    gamesFolder: path.join(__dirname, 'games'),
    botOwnerId: '1371360019425267794',
    embedColor: 0x5865F2,
    tempFolder: path.join(__dirname, 'temp')
};

// Initialize client
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent
    ]
});

// Ensure folders exist
[config.gamesFolder, config.tempFolder].forEach(folder => {
    if (!fs.existsSync(folder)) fs.mkdirSync(folder);
});

client.once('ready', () => {
    console.log(`Logged in as ${client.user.tag}`);
    registerCommands();
});

client.on('interactionCreate', async interaction => {
    if (!interaction.isCommand() && !interaction.isButton()) return;

    // Handle button interactions
    if (interaction.isButton()) {
        if (interaction.customId.startsWith('download_')) {
            const appId = interaction.customId.split('_')[1];
            await handleDownloadButton(interaction, appId);
        }
        return;
    }

    // Handle command interactions
    if (!config.allowedGuildIds.includes(interaction.guildId)) {
        return interaction.reply({ content: '❌ This bot is not available in this server.', ephemeral: true });
    }
    if (config.blacklistedUserIds.includes(interaction.user.id)) {
        return interaction.reply({ content: '❌ You are blacklisted from using this bot.', ephemeral: true });
    }

    try {
        if (interaction.commandName === 'generate_file') {
            await handleGenerateFile(interaction);
        } else if (interaction.commandName === 'request_file') {
            await handleRequestFile(interaction);
        }
    } catch (error) {
        console.error('Error handling interaction:', error);
        interaction.reply({ content: '❌ An error occurred while processing your command.', ephemeral: true });
    }
});

async function handleGenerateFile(interaction) {
    const appId = interaction.options.getString('appid');
    const startTime = Date.now();

    // Get game info from Steam
    const gameInfo = await getSteamGameInfo(appId);

    if (!gameInfo) {
        return interaction.reply({ content: '❌ Could not find game with that App ID.', ephemeral: true });
    }

    // Check if file exists in games folder
    const gameFiles = fs.readdirSync(config.gamesFolder);
    const matchingFile = gameFiles.find(file => file.includes(appId));

    if (!matchingFile) {
        const notFoundEmbed = new EmbedBuilder()
            .setColor(0xFF0000)
            .setTitle(`❌ ${gameInfo.name} (AppID: ${appId})`)
            .setDescription('**Game Info**\nName: ' + gameInfo.name + '\nAppID: ' + appId)
            .addFields(
                { name: '⚠️ Status', value: 'No files found in Sushi\'s Database' },
                { name: 'ℹ️ Additional Info', value: gameInfo.short_description || 'No description available' }
            )
            .setFooter({
                text: `Requested by ${interaction.user.username} | Made by u8ej with ❤️`,
                iconURL: interaction.user.displayAvatarURL()
            });

        if (gameInfo.header_image) {
            notFoundEmbed.setThumbnail(gameInfo.header_image);
        }

        return interaction.reply({ embeds: [notFoundEmbed] });
    }

    // Get file stats
    const filePath = path.join(config.gamesFolder, matchingFile);
    const stats = fs.statSync(filePath);
    const fileSize = formatSize(stats.size);
    const endTime = Date.now();
    const elapsedTime = ((endTime - startTime) / 1000).toFixed(2) + 's';

    // Create rich embed
    const embed = new EmbedBuilder()
        .setColor(config.embedColor)
        .setTitle(`🎮 ${gameInfo.name} (AppID: ${appId})`)
        .setDescription(`**📝 Game Info**\n🔹 **Name:** ${gameInfo.name}\n🔹 **AppID:** ${appId}\n\n${gameInfo.short_description || 'No description available'}`)
        .addFields(
            { name: '📦 Manifest Details', value: `🔹 **Size:** ${fileSize}` },
            { name: '⚡ Performance', value: `🔹 **Time:** ${elapsedTime}\n🔹 **Status:** ✅ Success` }
        )
        .setFooter({
            text: `Generated by ${interaction.user.username} | Made by u8ej with ❤️`,
            iconURL: interaction.user.displayAvatarURL()
        });

    if (gameInfo.header_image) {
        embed.setThumbnail(gameInfo.header_image);
    }

    // Create buttons
    const row = new ActionRowBuilder()
        .addComponents(
            new ButtonBuilder()
                .setCustomId(`download_${appId}`)
                .setLabel('⬇️ Download ZIP')
                .setStyle(ButtonStyle.Primary),
            new ButtonBuilder()
                .setLabel('🛒 Steam Store')
                .setStyle(ButtonStyle.Link)
                .setURL(`https://store.steampowered.com/app/${appId}`),
            new ButtonBuilder()
                .setLabel('📊 SteamDB')
                .setStyle(ButtonStyle.Link)
                .setURL(`https://steamdb.info/app/${appId}`)
        );

    // Send the embed to everyone (without file)
    await interaction.reply({ embeds: [embed], components: [row] });
}

async function handleDownloadButton(interaction, appId) {
    await interaction.deferReply({ ephemeral: true });

    // Check if file exists in games folder
    const gameFiles = fs.readdirSync(config.gamesFolder);
    const matchingFile = gameFiles.find(file => file.includes(appId));

    if (!matchingFile) {
        return interaction.editReply({ content: '❌ File no longer available in the database.' });
    }

    const filePath = path.join(config.gamesFolder, matchingFile);

    // Create a temporary zip file
    const tempZipPath = path.join(config.tempFolder, `${appId}_${Date.now()}.zip`);
    const output = fs.createWriteStream(tempZipPath);
    const archive = archiver('zip', { zlib: { level: 9 } });

    output.on('close', async () => {
        try {
            // Send the zip file
            await interaction.editReply({
                content: '✅ Here is your requested file:',
                files: [tempZipPath]
            });

            // Clean up after sending
            setTimeout(() => {
                fs.unlink(tempZipPath, () => {});
            }, 30000);
        } catch (error) {
            console.error('Error sending file:', error);
            interaction.editReply({ content: '❌ Failed to send the file.' });
        }
    });

    archive.on('error', (err) => {
        console.error('Archive error:', err);
        interaction.editReply({ content: '❌ Error creating zip file.' });
    });

    archive.pipe(output);
    archive.file(filePath, { name: matchingFile });
    await archive.finalize();
}

async function handleRequestFile(interaction) {
    const appId = interaction.options.getString('appid');
    const startTime = Date.now();

    // Get game info from Steam
    const gameInfo = await getSteamGameInfo(appId);

    if (!gameInfo) {
        return interaction.reply({ content: '❌ Could not find game with that App ID.', ephemeral: true });
    }

    // Get target user (bot owner)
    let targetUser;
    try {
        targetUser = await client.users.fetch(config.botOwnerId);
    } catch {
        return interaction.reply({ content: '❌ Could not find the bot owner.', ephemeral: true });
    }

    // Check if file exists
    const gameFiles = fs.readdirSync(config.gamesFolder);
    const matchingFile = gameFiles.find(file => file.includes(appId));
    const endTime = Date.now();
    const elapsedTime = ((endTime - startTime) / 1000).toFixed(2) + 's';

    let fileInfo = '❌ No files found in Sushi\'s Database';
    if (matchingFile) {
        const filePath = path.join(config.gamesFolder, matchingFile);
        const stats = fs.statSync(filePath);
        fileInfo = `📦 Size: ${formatSize(stats.size)}`;
    }

    // Create embed
    const embed = new EmbedBuilder()
        .setColor(config.embedColor)
        .setTitle(`📩 File Request: ${gameInfo.name}`)
        .setDescription(`**📝 Request Details**\n🎮 **Game:** ${gameInfo.name}\n🔹 **AppID:** ${appId}\n\n${gameInfo.short_description || 'No description available'}`)
        .addFields(
            { name: '📊 Manifest Details', value: fileInfo },
            { name: '⚡ Performance', value: `🔹 **Time:** ${elapsedTime}\n🔹 **Status:** ✅ Success` },
            { name: '👤 Requester', value: interaction.user.toString() },
            { name: '🎯 Requested For', value: targetUser.toString() }
        )
        .setFooter({
            text: `SushiTools System • Generated by u8ej • ${new Date().toLocaleString()}`,
            iconURL: interaction.user.displayAvatarURL()
        });

    if (gameInfo.header_image) {
        embed.setThumbnail(gameInfo.header_image);
    }

    // Create buttons
    const row = new ActionRowBuilder()
        .addComponents(
            new ButtonBuilder()
                .setCustomId(`download_${appId}`)
                .setLabel('⬇️ Download ZIP')
                .setStyle(ButtonStyle.Primary),
            new ButtonBuilder()
                .setLabel('🛒 Steam Store')
                .setStyle(ButtonStyle.Link)
                .setURL(`https://store.steampowered.com/app/${appId}`),
            new ButtonBuilder()
                .setLabel('📊 SteamDB')
                .setStyle(ButtonStyle.Link)
                .setURL(`https://steamdb.info/app/${appId}`)
        );

    // Send the request
    await interaction.reply({ content: '✅ Your request has been sent to the bot owner.', ephemeral: true });

    // Notify the target user (bot owner)
    try {
        await targetUser.send({
            content: `📩 ${interaction.user.tag} has requested a file: ${gameInfo.name} (AppID: ${appId})`,
            embeds: [embed],
            components: [row]
        });
    } catch (error) {
        console.error('Could not DM user:', error);
        await interaction.followUp({
            content: `❌ Could not send DM to the bot owner. They may have DMs disabled.`,
            ephemeral: true
        });
    }
}

async function getSteamGameInfo(appId) {
    try {
        const storeResponse = await axios.get(`https://store.steampowered.com/api/appdetails?appids=${appId}`);
        const storeData = storeResponse.data[appId];

        if (!storeData || !storeData.success) {
            return null;
        }

        return {
            name: storeData.data.name,
            header_image: storeData.data.header_image,
            short_description: storeData.data.short_description || null,
            developers: storeData.data.developers ? storeData.data.developers.join(', ') : 'Unknown',
            publishers: storeData.data.publishers ? storeData.data.publishers.join(', ') : 'Unknown',
            release_date: storeData.data.release_date ? storeData.data.release_date.date : 'Unknown'
        };
    } catch (error) {
        console.error('Error getting Steam game info:', error);
        return null;
    }
}

function formatSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function registerCommands() {
    // In a production environment, you would register these commands with Discord
    const commands = [
        {
            name: 'generate_file',
            description: 'Generate a file for a game using its Steam App ID',
            options: [
                {
                    name: 'appid',
                    description: 'The Steam App ID of the game',
                    type: 3, // STRING
                    required: true
                }
            ]
        },
        {
            name: 'request_file',
            description: 'Request a file for a game using its Steam App ID',
            options: [
                {
                    name: 'appid',
                    description: 'The Steam App ID of the game',
                    type: 3, // STRING
                    required: true
                }
            ]
        }
    ];

    console.log('Commands registered:', commands.map(c => c.name).join(', '));
}

client.login('MTM3NTE2NTA5NzAzODcwODkxOA.G2r83W.9r7nNJTBjrzcK9z9DIy8a7oXYG3hvv8aHXft-k');
